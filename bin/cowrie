#!/bin/bash
################################################################################
# Don't edit this file
#
# Environment variables can be passed to change how this script runs.
#
# Set `COWRIE_VIRTUAL_ENV=my-env` to use a particular virtual environment.
# By default Cowrie will look for `cowrie-env` in the current or parent
# directory.
#
# Set `COWRIE_STDOUT=yes` to run in foreground mode and send logs to stdout
#
# Pass any other config variable as well, to further setup your environment!
# For example: `COWRIE_TELNET_ENABLED=yes`
################################################################################

DEFAULT_VIRTUAL_ENV=cowrie-env

first_time_use() {
    echo
    echo "Join the Cowrie community at: https://www.cowrie.org/slack/"
    echo
}

python_version_warning() {
    if python -V 2>&1 | grep -q  '^Python 2.'; then
        echo
        echo "DEPRECATION: Python 2.7 reached the end of its life on January 1st, 2020."
        echo "Cowrie has dropped support for Python 2.7."
        echo
    fi
    if python -V 2>&1 | grep -q  '^Python 3.5'; then
        echo
        echo "DEPRECATION: Python 3.5 is no longer supported by Cowrie."
        echo
    fi
}

find_cowrie_directory() {
    # Determine Cowrie directory, $0 is a shell variable which holds the name of the currently executing script
    # it is assumed that Cowrie directory is one level above scripts location
    if [[ "$0" = /* ]] # if script was invoked with abs path (starting with /)
    then
        COWRIEDIR=$(dirname $0)/..
    else # else if script is invoked with relative path
        COWRIEDIR=$(dirname $PWD/$0)/.. # an absolute path is constructed by combining current working directory and scripts location
    fi
    COWRIEDIR=$(cd ${COWRIEDIR} && pwd -P 2>/dev/null || pwd)
}

activate_venv() {
    # Activate Python virtual environment
    VENV="$1" # takes one arg
    if [ ! -f "$VENV/bin/activate" ] # VENV is path to virtual env directory, checks if this file exists
    then
        return 1 # if doesnt exist, returns 1 err code
    fi
    . $VENV/bin/activate # executes the activate script withing virtual env
    return 0
}

cowrie_status() {
    # Check and Print status
    PID=$(cat ${PIDFILE} 2>/dev/null || echo "") # reads contents of the file specified by PIDFILE, PIDFILE likely contains the PID of the running cowrie instance
    # ^if file doesnt exist or there is an error, an empty string is assigned to the PID
    if [ -n "$PID" ]; then # checks if PID is not empty (if Cowrie PID exists or no)
        if ps -p "$PID" 2>&1 >/dev/null; then # use ps to check if process with the PID is running
            echo "cowrie is running (PID: ${PID})."
        else
            echo "cowrie is not running (PID: ${PID})."
            echo "Removing stale PID file ${PIDFILE}"
            rm -f ${PIDFILE}
        fi
    else
        echo "cowrie is not running."
    fi
}

# bin/cowrie generate src/cowrie/shell/generate.py <any input name>
# This function is to generate all the caching information before starting cowrie honeypot. 
cowrie_generate() {
    # call a python script that generates everything 
    # ***When assigning a value to variable in bash, there should not be any spaces between, PYTHONSCRIPT = "$1"
    PYTHONSCRIPT="$1" # send in the first argument which would be the python path 
    python3 "$PYTHONSCRIPT" "$@" # send in the remaining args to the function
    printf "Python file path is %s.\n" $PYTHONSCRIPT 
    echo "Python script running..."

    # checking if python script has ran successfully
    # check if exit status is 0, exit status is $?
    if [ $? -eq 0 ]; then 
        echo "Script has successfully run"
    else
        echo "Script has failed to run"
    fi
}

cowrie_start() {
    # Start Cowrie
    COWRIEARGS="$*" # assigns all arguments to the variable
    TWISTEDARGS="${XARGS} --umask=0022 --pidfile=${PIDFILE}" # constructs arguments for the twisted command

    # Run foreground or background. Foreground has no file log.
    if [ "$COWRIE_STDOUT" = "yes" ]; then
        TWISTEDARGS="${TWISTEDARGS} -n -l -" # runs in the foreground without file logging
    else
        TWISTEDARGS="${TWISTEDARGS} --logger cowrie.python.logfile.logger"
    fi

    # 1. Check if any virtual environment is active
    # 2. Try COWRIE_VIRTUAL_ENV if defined
    # 3. Try DEFAULT_VIRTUAL_ENV
    # 4. Try ../DEFAULT_VIRTUAL_ENV
    # 5. Try without virtual environment

    if [ ! -z "$VIRTUAL_ENV" ]; then
        echo 2>&1 "Using activated Python virtual environment \"$VIRTUAL_ENV\""
    elif activate_venv "$COWRIE_VIRTUAL_ENV"; then
        echo 2>&1 "Using custom Python virtual environment \"$VIRTUAL_ENV\""
    elif activate_venv "$DEFAULT_VIRTUAL_ENV"; then
        echo 2>&1 "Using default Python virtual environment \"$VIRTUAL_ENV\""
    # Look one directory higher for the virtual env to not pollute the Cowrie dir
    elif activate_venv "../$DEFAULT_VIRTUAL_ENV"; then
        echo 2>&1 "Using default Python virtual environment \"../$VIRTUAL_ENV\""
    else
        echo 2>&1 "Not using Python virtual environment"
    fi

    python_version_warning

    # Automatically check if the authbind is enabled or not
    # authbind is utility that allows non root processes to bind to privileged ports (those below 1024)
    authfile="/etc/authbind/byport/22"
    if [ -z ${AUTHBIND_ENABLED} ] && [ -x "$authfile" ] && command -v authbind >/dev/null; then
        AUTHBIND_ENABLED=yes
    else
        AUTHBIND_ENABLED=no
    fi

    echo "Starting cowrie: [twistd ${TWISTEDARGS} cowrie ${COWRIEARGS}]..."
    if [ "$AUTHBIND_ENABLED" = "no" ]
    then
        exec twistd ${TWISTEDARGS} ${COWRIEARGS} cowrie
    else
        exec authbind --deep twistd ${TWISTEDARGS} ${COWRIEARGS} cowrie
    fi
}

cowrie_stop () {
    # Stop Cowrie
    PID=$(cat ${PIDFILE} 2>/dev/null || echo "")
    if [ -n "$PID" ]; then
      echo "Stopping cowrie..."
      if kill -TERM $PID; then
          echo -n
      else
          echo "Removing stale PID file ${PIDFILE}"
          rm -f ${PIDFILE}
      fi
    else
        echo "cowrie is not running."
    fi
}

cowrie_force_stop () {
    # Force Stop Cowrie
    PID=$(cat ${PIDFILE} 2>/dev/null || echo -n "")
    if [ -n "$PID" ]; then
        echo -n "Stopping cowrie..."
        if kill -TERM $PID; then
            ((t = 60))
            while ((t > 1)); do
                sleep 1
                echo -n .
                if kill -0 $PID 2>/dev/null; then
                    ((t -= 1))
                else
                    echo "terminated."
                    return
                fi
            done
            kill -KILL $PID
            echo "killed."
        else
            echo "Removing stale PID file ${PIDFILE}"
            rm -f ${PIDFILE}
        fi
    else
        echo "cowrie is not running."
    fi
}

cowrie_usage() {
    echo "usage: $0 <start|stop|force-stop|restart|status|shell|generate>"
}

# Mostly for Docker use, to quickly get a shell in the container
cowrie_shell() {
    $SHELL
}

################################################################################
## Main script
################################################################################

if [ "$#" = 0 ]
then
    cowrie_usage
    exit 1
fi

find_cowrie_directory $0
cd ${COWRIEDIR}
export PYTHONPATH=${PYTHONPATH}:${COWRIEDIR}/src

set -e

# Don't store pidfile on Docker persistent volume
if [ "${COWRIE_STDOUT}" = "yes" ]; then
        PIDFILE=""
else
        PIDFILE=var/run/cowrie.pid
fi

if [ ! -f ${COWRIEDIR}/var/log/cowrie/cowrie.log ]
then
    first_time_use
fi

key=$1
shift 1
case $key in
    stop)
        cowrie_stop $* # invokes function with any additional arguments ($*)
        ;;
    force-stop)
        cowrie_force_stop $*
        ;;
    start)
        cowrie_start $*
        ;;
    restart)
        cowrie_stop $*
        cowrie_start $*
        ;;
    status)
        cowrie_status $*
        ;;
    generate)
        cowrie_generate $*
        ;;
    bash)
        cowrie_shell $*
        ;;
    sh)
        cowrie_shell $*
        ;;
    shell)
        cowrie_shell $*
        ;;
    *)
        cowrie_usage
        exit 1
        ;;
esac
